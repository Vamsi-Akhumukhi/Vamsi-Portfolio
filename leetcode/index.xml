<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcodes on Vamsi&#39;s Portfolio</title>
    <link>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/</link>
    <description>Recent content in Leetcodes on Vamsi&#39;s Portfolio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 30 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>100. Same Tree</title>
      <link>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/100.-same-tree/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/100.-same-tree/</guid>
      <description>Description  Given the roots of two binary trees p and q, write a function to check if they are the same or not.
  Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
 Test cases Example 1
Input: p = [1,2,3] and q = [1,2,3] Output: true  Example 2
Input: p = [1,2], q = [1,null,2] Output: false  Solution: We need to do recursion to check if two binary trees are structurally identical and nodes has the same value</description>
    </item>
    
    <item>
      <title>771. Jewels and Stones</title>
      <link>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/771.-jewels-and-stones/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/771.-jewels-and-stones/</guid>
      <description>Description  You&amp;rsquo;re given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.
  Letters are case sensitive, so &amp;ldquo;a&amp;rdquo; is considered a different type of stone from &amp;ldquo;A&amp;rdquo;.
 Test cases Example 1
Input: jewels = &amp;quot;aA&amp;quot;, stones = &amp;quot;aAAbbbb&amp;quot; Output: 3  Example 2</description>
    </item>
    
    <item>
      <title>1047. Remove All Adjacent Duplicates In String</title>
      <link>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/1047.-remove-all-adjacent-duplicates-in-string/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/1047.-remove-all-adjacent-duplicates-in-string/</guid>
      <description>Description  Given a string s containing only lowercase letters, continuously remove adjacent characters that are the same and return the result.
 Test cases Example 1
Input: s = &amp;quot;abbcccccaa&amp;quot; Output: &amp;quot;ca&amp;quot;  Example 2
Input: s = &amp;quot;abccba&amp;quot; Output: &amp;quot;&amp;quot;  Example 3
Input: s = &amp;quot;mbccbefddfe&amp;quot; Output: &amp;quot;m&amp;quot;  Solution We start with a result stack, go through all the characters in the string S one by one.</description>
    </item>
    
    <item>
      <title>844. Backspace String Compare</title>
      <link>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/844.-backspace-string-compare/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/844.-backspace-string-compare/</guid>
      <description>Given two strings s and t, which represents a sequence of keystrokes, where # denotes a backspace, return whether or not the sequences produce the same result.
 Example 1
Input: s = &amp;quot;ABC#&amp;quot;, t = &amp;quot;CD##AB&amp;quot; Output: true  Example 2
Input: s = &amp;quot;como#pur#ter&amp;quot;, t = &amp;quot;computer&amp;quot; Output: true  Example 3
Input: &amp;quot;cof#dim#ng&amp;quot;, t = &amp;quot;coding&amp;quot; Output: false  class Solution: def backspaceCompare(self, S: str, T: str) -&amp;gt; bool: def build(S): res = [] for char in S: if char !</description>
    </item>
    
    <item>
      <title>19. Remove Nth Node From End of List</title>
      <link>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/remove-nth-last-node-from-linked-list/remove-nth-last-node-from-linked-list/</link>
      <pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/remove-nth-last-node-from-linked-list/remove-nth-last-node-from-linked-list/</guid>
      <description>Given the head of a linked list, remove the nth node from the end of the list and return its head.
  Follow up: Could you do this in one pass?
 Example 1
Input: head = [1,2,3,4,5,6], n = 2 Output: [1,2,3,4,6]  Example 2
Input: head = [2], n = 1 Output: []  Example 3
Input: head = [1,2,3], n = 1 Output: [1,2]  # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>21.  Merge Two Sorted Lists</title>
      <link>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/merge-two-sorted-linked-lists/</link>
      <pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/merge-two-sorted-linked-lists/</guid>
      <description>Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.
 Example 1
Input: l1 = [-1,2,4], l2 = [1,3,4] Output: [-1,1,2,3,4,4]  Example 2
Input: l1 = [-1,4,5,7,8,9,10], l2 = [1,3,4] Output: [-1,1,3,4,4,5,7,8,9,10]  Example 3
Input: l1 = [], l2 = [1,3,4] Output: [1,3,4]  class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&amp;gt; ListNode: dummy = curr = ListNode(0) #current always points to the tail of the list if l1: curr.</description>
    </item>
    
    <item>
      <title>520. Detect Capital</title>
      <link>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/detect-capital/</link>
      <pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://vamsi-akhumukhi.github.io/Vamsi-Portfolio/leetcode/detect-capital/</guid>
      <description>Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds:
  All letters in this word are capitals, like &amp;ldquo;AMERICA&amp;rdquo;. All letters in this word are not capitals, like &amp;ldquo;vamsi&amp;rdquo;. Only the first letter in this word is capital, like &amp;ldquo;Predator&amp;rdquo;.  class Solution: def detectCapitalUse(self, word: str) -&amp;gt; bool: return (word[0] == word[0].</description>
    </item>
    
  </channel>
</rss>
